<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcard H√°n Vi·ªát - T√≠nh nƒÉng Ph√°t √¢m (Web Speech)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&family=Quicksand:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Quicksand', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        .chinese-font {
            font-family: 'Noto Sans SC', sans-serif;
        }
        /* Styling cho Slider */
        #card-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #2563eb;
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 0 0 1px #2563eb;
        }
        #card-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #2563eb;
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 0 0 1px #2563eb;
        }
        .card-display {
            display: block;
            min-height: 25rem; 
        }
        .speak-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body class="bg-slate-100 flex flex-col items-center justify-center min-h-screen p-4">

    <!-- Thanh ƒëi·ªÅu h∆∞·ªõng v√† Slider -->
    <div class="w-full max-w-lg mx-auto mb-6 flex flex-col items-center">
        <!-- B·ªô ƒë·∫øm v√† Slider -->
        <div class="w-full mb-4">
            <div id="topic-indicator" class="text-center text-green-600 mb-2 font-bold text-lg"></div>
            <div id="card-counter" class="text-center text-slate-600 mb-3 font-medium text-lg"></div>
            <input type="range" id="card-slider" min="1" max="100" value="1" class="w-full h-2 bg-blue-200 rounded-lg appearance-none cursor-pointer">
        </div>
        <!-- N√∫t ƒëi·ªÅu khi·ªÉn -->
        <div class="flex items-center space-x-4 w-full justify-center">
            <button id="prev-btn" class="bg-gray-400 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-gray-500 transition-transform transform hover:scale-105 text-base md:text-lg">
                &larr; Tr∆∞·ªõc
            </button>
            <button id="next-btn" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg shadow-md hover:bg-blue-700 transition-transform transform hover:scale-105 text-base md:text-lg">
                Ti·∫øp theo &rarr;
            </button>
        </div>
        
        <!-- Dropdown ch·ªçn ch·ªß ƒë·ªÅ -->
        <div class="mt-4">
            <label for="topic-select" class="block text-sm font-medium text-gray-700 mb-2">Ch·ªçn ch·ªß ƒë·ªÅ:</label>
            <select id="topic-select" class="bg-white border border-gray-300 rounded-lg px-4 py-2 text-base font-medium text-gray-700 shadow-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent min-w-48">
                <!-- Options will be populated by JavaScript -->
            </select>
        </div>
    </div>
    
    <!-- Container cho Flashcard -->
    <div id="flashcard" class="card-display bg-white p-6 md:p-8 rounded-xl shadow-xl w-full max-w-lg mb-8 transition-all duration-300">
        <!-- Ph·∫ßn H√°n t·ª± v√† Pinyin -->
        <div class="text-center mb-6 border-b pb-4 border-slate-200">
            <div class="flex justify-center items-center">
                <!-- Hanzi ch√≠nh v√† N√∫t ph√°t √¢m (S√°t nhau) -->
                <p id="card-hanzi-pinyin" class="chinese-font text-5xl md:text-7xl font-bold text-slate-900 leading-tight"></p>
                <button id="speak-main-btn" class="speak-btn ml-2 text-blue-600 hover:text-blue-800 transition duration-150 p-2 rounded-full hover:bg-blue-50" aria-label="Ph√°t √¢m t·ª´ n√†y">
                    <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-volume-2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>
                </button>
            </div>
            <p id="card-pinyin-only" class="text-2xl text-blue-600 mt-1 font-medium"></p>
        </div>

        <!-- Ph·∫ßn Nghƒ©a v√† H√°n Vi·ªát -->
        <div class="space-y-3 text-lg md:text-xl text-left text-slate-800 mb-6">
            <p><strong>√Çm H√°n Vi·ªát:</strong> <span id="card-hanviet" class="font-semibold text-slate-700"></span></p>
            <p><strong>Nghƒ©a Vi·ªát:</strong> <span id="card-vietnamese" class="font-extrabold text-red-600"></span></p>
        </div>

        <!-- Ph·∫ßn Ph√¢n t√≠ch T·ª´ gh√©p -->
        <div class="mt-6 pt-4 border-t border-slate-200">
            <p class="text-base font-bold text-slate-700 mb-3 border-b pb-2">Ph√¢n t√≠ch t·ª´ g·ªëc:</p>
            
            <!-- T·ª´ gh√©p Set 1 -->
            <div id="char1-related-container" class="mb-4">
                <!-- N·ªôi dung s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t b·∫±ng JS -->
            </div>

            <!-- T·ª´ gh√©p Set 2 -->
            <div id="char2-related-container">
                <!-- N·ªôi dung s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t b·∫±ng JS -->
            </div>
        </div>
    </div>
    
    <script>
        // --- C·∫•u h√¨nh v√† Data ---
        let flashcards = []; // Will be loaded from JSON
        let currentIndex = 0;
        let totalCards = 0;
        
        // --- Topic Management ---
        let topics = [];
        let currentTopicIndex = 0;
        
        // Danh s√°ch c√°c file JSON c·∫ßn ki·ªÉm tra
        const jsonFiles = [
            'default.json',
            'hospital.json', 
            'kitchen.json',
            'body.json',
            'smartphone.json',
            'planets.json',
            'dinosaurs.json',
            'study_supplies.json',
            'vegetables.json',
            'dishes.json',
            'drinking.json',
            'radicals.json'
        ];
        
        // H√†m ki·ªÉm tra file JSON c√≥ t·ªìn t·∫°i kh√¥ng
        async function checkJsonFileExists(filename) {
            try {
                const response = await fetch(filename, { method: 'HEAD' });
                return response.ok;
            } catch (error) {
                return false;
            }
        }
        
        // H√†m t·ª± ƒë·ªông scan v√† t·∫°o danh s√°ch topics
        async function scanAndCreateTopics() {
            topics = [];
            
            for (const filename of jsonFiles) {
                const exists = await checkJsonFileExists(filename);
                if (exists) {
                    // T·ª± ƒë·ªông t·∫°o t√™n hi·ªÉn th·ªã t·ª´ t√™n file
                    const displayName = filename.replace('.json', '').replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    topics.push({
                        name: displayName,
                        file: filename
                    });
                }
            }
            
            console.log('ƒê√£ t√¨m th·∫•y c√°c file JSON:', topics.map(t => t.file));
            return topics;
        }

        // --- JSON Data Loading ---
        async function loadFlashcards(topicIndex = 0) {
            try {
                // ƒê·∫£m b·∫£o topics ƒë√£ ƒë∆∞·ª£c scan tr∆∞·ªõc khi load
                if (topics.length === 0) {
                    await scanAndCreateTopics();
                }
                
                if (topics.length === 0) {
                    throw new Error('Kh√¥ng t√¨m th·∫•y file JSON n√†o');
                }
                
                const topic = topics[topicIndex];
                const response = await fetch(topic.file);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                flashcards = await response.json();
                totalCards = flashcards.length;
                currentTopicIndex = topicIndex;
                
                // Update topic dropdown and indicator
                populateTopicDropdown();
                updateTopicIndicator();
                
                // Initialize the application after data is loaded
                initializeCardDisplay();
            } catch (error) {
                console.error('Error loading flashcards:', error);
                // Show error message to user
                document.getElementById('flashcard').innerHTML = 
                    '<div class="text-center text-red-600 p-8"><h2 class="text-xl font-bold mb-4">L·ªói t·∫£i d·ªØ li·ªáu</h2><p>Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu flashcard. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi m·∫°ng v√† th·ª≠ l·∫°i.</p></div>';
            }
        }
        
        function populateTopicDropdown() {
            // Clear existing options
            topicSelect.innerHTML = '';
            
            // Add options for each topic
            topics.forEach((topic, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = topic.name;
                if (index === currentTopicIndex) {
                    option.selected = true;
                }
                topicSelect.appendChild(option);
            });
        }
        
        function updateTopicIndicator() {
            const currentTopic = topics[currentTopicIndex];
            topicIndicator.textContent = `üìö ${currentTopic.name}`;
        }
        
        async function switchTopic(selectedIndex) {
            currentIndex = 0; // Reset to first card
            await loadFlashcards(selectedIndex);
        }

        function initializeCardDisplay() {
            // Update slider max value
            document.getElementById('card-slider').max = totalCards;
            
            // Display the first card
            displayCard(currentIndex);
        }
        const nextBtn = document.getElementById('next-btn');
        const prevBtn = document.getElementById('prev-btn');
        const cardCounter = document.getElementById('card-counter');
        const cardSlider = document.getElementById('card-slider');
        const topicSelect = document.getElementById('topic-select');
        const topicIndicator = document.getElementById('topic-indicator');

        const hanziPinyinEl = document.getElementById('card-hanzi-pinyin');
        const pinyinOnlyEl = document.getElementById('card-pinyin-only');
        const hanvietEl = document.getElementById('card-hanviet');
        const vietnameseEl = document.getElementById('card-vietnamese');
        const speakMainBtn = document.getElementById('speak-main-btn');

        const char1Container = document.getElementById('char1-related-container');
        const char2Container = document.getElementById('char2-related-container');

        // --- Web Speech API Configuration ---
        let chineseVoice = null;
        let isSpeaking = false;

        // T·∫£i danh s√°ch gi·ªçng ƒë·ªçc v√† t√¨m gi·ªçng ti·∫øng Trung (zh-CN)
        function loadChineseVoice() {
            const voices = window.speechSynthesis.getVoices();
            // ∆Øu ti√™n t√¨m gi·ªçng c√≥ lang b·∫Øt ƒë·∫ßu b·∫±ng 'zh-' ho·∫∑c c√≥ t√™n li√™n quan ƒë·∫øn Chinese/Mandarin
            chineseVoice = voices.find(voice => 
                voice.lang.startsWith('zh-') || 
                voice.lang.includes('cmn-') || 
                voice.name.toLowerCase().includes('chinese') || 
                voice.name.toLowerCase().includes('mandarin')
            );
            
            if (!chineseVoice) {
                console.warn("Kh√¥ng t√¨m th·∫•y gi·ªçng ti·∫øng Trung c·ª• th·ªÉ. S·ª≠ d·ª•ng gi·ªçng m·∫∑c ƒë·ªãnh.");
            }
        }

        // T·∫£i gi·ªçng khi voiceschanged s·ª± ki·ªán k√≠ch ho·∫°t (ƒë·∫£m b·∫£o gi·ªçng ƒë√£ s·∫µn s√†ng)
        loadChineseVoice();
        if ('onvoiceschanged' in window.speechSynthesis) {
            window.speechSynthesis.onvoiceschanged = loadChineseVoice;
        }

        /**
         * H√†m ph√°t √¢m ti·∫øng Trung s·ª≠ d·ª•ng Web Speech API.
         * @param {string} textToSpeak - VƒÉn b·∫£n H√°n t·ª± ho·∫∑c Pinyin c·∫ßn ph√°t √¢m.
         * @param {HTMLElement} elementToUpdate - N√∫t b·∫•m ƒë·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i UI.
         */
        function speakChinese(textToSpeak, elementToUpdate) {
            if (isSpeaking) {
                console.log("ƒêang c√≥ ph√°t √¢m kh√°c ƒëang ch·∫°y.");
                // D·ª´ng ph√°t √¢m c≈© tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu c√°i m·ªõi
                window.speechSynthesis.cancel(); 
                isSpeaking = false;
                // N·∫øu n√∫t c≈© ƒëang disabled, k√≠ch ho·∫°t l·∫°i
                if(document.querySelector('.speak-btn.opacity-50')) {
                    const oldBtn = document.querySelector('.speak-btn.opacity-50');
                    oldBtn.disabled = false;
                    oldBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            }

            if (!window.speechSynthesis) {
                console.error("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Web Speech API.");
                return;
            }

            const utterance = new SpeechSynthesisUtterance(textToSpeak.replace(/ /g, '')); // Lo·∫°i b·ªè kho·∫£ng tr·∫Øng cho Pinyin li·ªÅn m·∫°ch
            
            if (chineseVoice) {
                utterance.voice = chineseVoice;
            } else {
                utterance.lang = 'zh-CN'; 
            }
            
            utterance.rate = 0.8; 

            // Qu·∫£n l√Ω tr·∫°ng th√°i UI trong khi ƒë·ªçc
            utterance.onstart = () => {
                isSpeaking = true;
                elementToUpdate.disabled = true;
                elementToUpdate.classList.add('opacity-50', 'cursor-not-allowed');
            };

            utterance.onend = () => {
                isSpeaking = false;
                elementToUpdate.disabled = false;
                elementToUpdate.classList.remove('opacity-50', 'cursor-not-allowed');
            };

            utterance.onerror = (event) => {
                isSpeaking = false;
                elementToUpdate.disabled = false;
                elementToUpdate.classList.remove('opacity-50', 'cursor-not-allowed');
                console.error('L·ªói ph√°t √¢m Web Speech:', event.error);
            };

            window.speechSynthesis.speak(utterance);
        }

        // H√†m helper ƒë·ªÉ render danh s√°ch t·ª´ gh√©p v√† th√™m n√∫t ph√°t √¢m
        function renderRelatedWords(containerEl, charData, charIndex) {
            containerEl.innerHTML = ''; 
            
            if (charData) {
                const headerP = document.createElement('p');
                headerP.className = 'text-sm font-bold text-slate-600 mb-2 flex items-center';
                
                const charSpan = document.createElement('span');
                charSpan.className = 'chinese-font text-lg text-blue-800 mr-2';
                charSpan.textContent = charData.hanzi;

                const pinyinSpan = document.createElement('span');
                pinyinSpan.textContent = `(${charData.pinyin}, ${charData.hanviet})`;

                const speakCharBtn = document.createElement('button');
                speakCharBtn.className = 'speak-btn ml-2 text-indigo-600 hover:text-indigo-800 p-1 rounded-full hover:bg-indigo-100 transition duration-150';
                speakCharBtn.ariaLabel = `Ph√°t √¢m H√°n t·ª± ${charData.hanzi}`;
                speakCharBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-volume-2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>';
                
                // G√°n s·ª± ki·ªán cho n√∫t ph√°t √¢m H√°n t·ª± th√†nh ph·∫ßn
                speakCharBtn.addEventListener('click', () => speakChinese(charData.hanzi, speakCharBtn)); // D√πng H√°n t·ª± ƒë∆°n
                
                headerP.appendChild(document.createTextNode(`${charIndex}. T·ª´ g·ªëc: `));
                headerP.appendChild(charSpan);
                headerP.appendChild(pinyinSpan);
                headerP.appendChild(speakCharBtn);

                containerEl.appendChild(headerP);

                // 2. T·∫°o container cho danh s√°ch t·ª´ gh√©p
                const wordsContainer = document.createElement('div');
                wordsContainer.className = 'flex flex-wrap gap-2 text-sm';
                
                if (charData.words && charData.words.length > 0) {
                    charData.words.forEach(word => {
                        const wordButton = document.createElement('button');
                        wordButton.className = 'speak-btn bg-indigo-100 text-indigo-800 px-3 py-1 rounded-full font-medium whitespace-nowrap text-sm md:text-base hover:bg-indigo-200 transition duration-150';
                        
                        const hanziText = document.createElement('span');
                        hanziText.className = 'chinese-font font-bold mr-1';
                        hanziText.textContent = word.hanzi;
                        
                        const infoText = document.createElement('span');
                        infoText.textContent = `(${word.pinyin}, ${word.hanviet})`;

                        const audioIcon = document.createElement('span');
                        audioIcon.className = 'ml-1';
                        audioIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-volume-1"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a2.16 2.16 0 0 1 0 3.08"/></svg>';

                        wordButton.appendChild(hanziText);
                        wordButton.appendChild(infoText);
                        wordButton.appendChild(audioIcon);

                        // G√°n s·ª± ki·ªán cho n√∫t ph√°t √¢m t·ª´ gh√©p
                        wordButton.addEventListener('click', () => speakChinese(word.hanzi, wordButton));
                        
                        wordsContainer.appendChild(wordButton);
                    });
                } else {
                    wordsContainer.textContent = 'Kh√¥ng c√≥ d·ªØ li·ªáu t·ª´ gh√©p m·ªü r·ªông cho t·ª´ n√†y.';
                    wordsContainer.className = 'text-slate-500 italic text-sm';
                }
                containerEl.appendChild(wordsContainer);
                containerEl.style.display = 'block';

            } else {
                containerEl.innerHTML = `<p class="text-slate-500 italic text-center text-base">D·ªØ li·ªáu ph√¢n t√≠ch t·ª´ g·ªëc ch∆∞a ƒë∆∞·ª£c cung c·∫•p cho th·∫ª n√†y.</p>`;
                containerEl.style.display = 'block'; 
            }
        }

        function displayCard(index) {
            const cardData = flashcards[index];
            
            // C·∫≠p nh·∫≠t H√°n t·ª± v√† Pinyin ch√≠nh
            hanziPinyinEl.textContent = cardData.hanzi;
            pinyinOnlyEl.textContent = `[${cardData.pinyin}]`;
            
            // C·∫≠p nh·∫≠t Nghƒ©a
            hanvietEl.textContent = cardData.hanviet;
            vietnameseEl.textContent = cardData.vietnamese;
            
            // G√°n s·ª± ki·ªán cho n√∫t ph√°t √¢m ch√≠nh (ph√°t √¢m c·∫£ t·ª´)
            speakMainBtn.onclick = () => speakChinese(cardData.hanzi, speakMainBtn); 

            // C·∫≠p nh·∫≠t th√¥ng tin chi ti·∫øt t·ª´ng k√Ω t·ª±
            renderRelatedWords(char1Container, cardData.char1, 1);
            renderRelatedWords(char2Container, cardData.char2, 2);

            // C·∫≠p nh·∫≠t b·ªô ƒë·∫øm v√† thanh tr∆∞·ª£t
            cardCounter.textContent = `Th·∫ª s·ªë: ${index + 1} / ${totalCards}`;
            cardSlider.value = index + 1;
        }

        function navigate(direction) {
            if (direction === 'next') {
                currentIndex = (currentIndex + 1) % totalCards;
            } else if (direction === 'prev') {
                currentIndex = (currentIndex - 1 + totalCards) % totalCards;
            }
            // ƒê·∫£m b·∫£o d·ª´ng ph√°t √¢m khi chuy·ªÉn th·∫ª
            window.speechSynthesis.cancel();
            displayCard(currentIndex);
        }

        // --- Event Listeners ---
        nextBtn.addEventListener('click', () => navigate('next'));
        prevBtn.addEventListener('click', () => navigate('prev'));
        topicSelect.addEventListener('change', async (event) => {
            const selectedIndex = parseInt(event.target.value);
            await switchTopic(selectedIndex);
        });

        cardSlider.addEventListener('input', (event) => {
            currentIndex = parseInt(event.target.value) - 1;
            // ƒê·∫£m b·∫£o d·ª´ng ph√°t √¢m khi k√©o thanh tr∆∞·ª£t
            window.speechSynthesis.cancel();
            displayCard(currentIndex);
        });

        // Load flashcards data from JSON and initialize the app
        // T·ª± ƒë·ªông scan v√† load file JSON ƒë·∫ßu ti√™n
        (async function initializeApp() {
            try {
                await scanAndCreateTopics();
                if (topics.length > 0) {
                    await loadFlashcards(0);
                } else {
                    console.error('Kh√¥ng t√¨m th·∫•y file JSON n√†o');
                    document.getElementById('flashcard').innerHTML = 
                        '<div class="text-center text-red-600 p-8"><h2 class="text-xl font-bold mb-4">Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu</h2><p>Kh√¥ng t√¨m th·∫•y file JSON n√†o trong th∆∞ m·ª•c. Vui l√≤ng ki·ªÉm tra l·∫°i.</p></div>';
                }
            } catch (error) {
                console.error('L·ªói kh·ªüi t·∫°o ·ª©ng d·ª•ng:', error);
            }
        })();
    </script>
</body>
</html>
